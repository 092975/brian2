{# USES_VARIABLES { Cm, dt, v, N,
                  ab_star0, ab_star1, ab_star2, b_plus,
                  ab_plus0, ab_plus1, ab_plus2, b_minus,
                  ab_minus0, ab_minus1, ab_minus2, v_star, u_plus, u_minus,
                  gtot_all, I0_all,
                  c1, c2, c3,
                  _P_diag, _P_parent, _P_children,
                  _B, _morph_parent_i, _starts, _ends,
                  _morph_children, _morph_children_num, _morph_idxchild,
                  _invr0, _invrn} #}
{# ITERATE_ALL { _idx } #}

'''
Solves the cable equation (spatial diffusion of currents).
This is where most time-consuming time computations are done.
'''
from numpy import zeros

# scalar code
_vectorisation_idx = 1
{{scalar_code|autoindent}}

# vector code
_vectorisation_idx = N
{{vector_code|autoindent}}

{%if _scipy_available %}
from scipy.linalg import solve_banded

# Particular solution
b=-({{Cm}}/{{dt}}*{{v}})-_I0
ab = zeros((3,N))
ab[0,:]={{ab_star0}}
ab[1,:]={{ab_star1}}
ab[2,:]={{ab_star2}}
ab[1,:]-=_gtot
{{v_star}}[:]=solve_banded((1,1),ab,b,overwrite_ab=True,overwrite_b=True)
# Homogeneous solutions
b[:]={{b_plus}}
ab[0,:]={{ab_plus0}}
ab[1,:]={{ab_plus1}}
ab[2,:]={{ab_plus2}}
ab[1,:]-=_gtot
{{u_plus}}[:]=solve_banded((1,1),ab,b,overwrite_ab=True,overwrite_b=True)
b[:]={{b_minus}}
ab[0,:]={{ab_minus0}}
ab[1,:]={{ab_minus1}}
ab[2,:]={{ab_minus2}}
ab[1,:]-=_gtot
{{u_minus}}[:]=solve_banded((1,1),ab,b,overwrite_ab=True,overwrite_b=True)
{% else %}
# Pure numpy solution, very slow because it needs forward and backward passes
# along the array that can't be vectorized
b = -({{Cm}} / {{dt}}*{{v}}) - _I0

# Tridiagonal solving
forward = range(1, N)
backward = range(N-2, -1, -1)
c = zeros(N)

# Pass 1
bi = {{ab_star1}} - _gtot  # main diagonal

# First compartment
c[0] = {{ab_star0}}[1] / bi[0]
{{v_star}}[0] = b[0] / bi[0]

# Other compartments
c[1:-1] = {{ab_star0}}[2:]
for i in forward:
    ai = {{ab_star2}}[i-1]  # subdiagonal
    _m = 1.0/(bi[i]-ai*c[i-1])
    c[i] *= _m
    {{v_star}}[i] = (b[i] - ai*{{v_star}}[i-1])*_m

for i in backward:
    {{v_star}}[i] -= c[i]*{{v_star}}[i+1]

# Pass 2
bi = {{ab_plus1}} - _gtot  # main diagonal

# First compartment
c[0] = {{ab_plus0}}[1]/bi[0]
{{u_plus}}[0] = {{b_plus}}[0]/bi[0]

# Other compartments
c[1:-1] = {{ab_plus0}}[2:]  # superdiagonal

for i in forward:
    ai = {{ab_plus2}}[i-1]  # subdiagonal
    _m = 1.0/(bi[i]-ai*c[i-1])
    c[i] *= _m
    {{u_plus}}[i] = ({{b_plus}}[i] - ai*{{u_plus}}[i-1])*_m

for i in backward:
    {{u_plus}}[i] -= c[i]*{{u_plus}}[i+1]

# Pass 3
bi = {{ab_minus1}} - _gtot  # main diagonal

# First compartment
c[0] = {{ab_minus0}}[1]/bi[0]
{{u_minus}}[0] = {{b_minus}}[0]/bi[0]

# Other compartments
c[1:-1] = {{ab_minus0}}[2:]  # superdiagonal
for i in forward:
    ai = {{ab_minus2}}[i-1]  # subdiagonal
    _m = 1.0/(bi[i]-ai*c[i-1]);
    c[i] *= _m
    {{u_minus}}[i] = ({{b_minus}}[i] - ai*{{u_minus}}[i-1])*_m

for i in backward:
    {{u_minus}}[i] -= c[i]*{{u_minus}}[i+1]
{% endif %}

# indexing for _P_children which contains the elements above the diagonal of the coupling matrix _P
children_rowlength = len({{_morph_children}})/len({{_morph_children_num}})

# Construct the coupling system with matrix _P in sparse form. s.t.
# _P_diag contains the diagonal elements
# _P_children contains the super diagonal entries
# _P_parent contains the single sub diagonal entry for each row
# _B contains the right hand side

_P_children_2d = {{_P_children}}.reshape(-1, children_rowlength)

for _i, (_i_parent, _i_childind, _first, _last, _invr0, _invrn) in enumerate(zip({{_morph_parent_i}},
                                                                                 {{_morph_idxchild}},
                                                                                 {{_starts}},
                                                                                 {{_ends}},
                                                                                 {{_invr0}},
                                                                                 {{_invrn}})):
    # Towards parent
    if _i == 0: # first branch, sealed end
        {{_P_diag}}[0] = {{u_minus}}[_first] - 1
        _P_children_2d[0, 0] = {{u_plus}}[_first]

        # RHS
        {{_B}}[0] = -{{v_star}}[_first]
    else:
        {{_P_diag}}[_i_parent] += (1 - {{u_minus}}[_first]) * _invr0
        _P_children_2d[_i_parent, _i_childind] = -{{u_plus}}[_first] * _invr0

        # RHS
        {{_B}}[_i_parent] += {{v_star}}[_first] * _invr0

    # Towards children
    {{_P_diag}}[_i+1] = (1 - {{u_plus}}[_last]) * _invrn
    {{_P_parent}}[_i] = -{{u_minus}}[_last] * _invrn

    # RHS
    {{_B}}[_i+1] = {{v_star}}[_last] * _invrn

# Solve the linear system (the result will be stored in the former rhs _B in the end)
# use efficient O(n) solution of the sparse linear system (structure-specific Gaussian elemination)
_morph_children_2d = {{_morph_children}}.reshape(-1, children_rowlength)

# part 1: lower triangularization

for _i in range(len({{_B}})-1, -1, -1):
    num_children = {{_morph_children_num}}[_i];

    for _k in range(num_children):
        _j = _morph_children_2d[_i, _k]  # child index

        # subtracting subfac times the j-th from the i-th row
        subfac = _P_children_2d[_i, _k] / {{_P_diag}}[_j]

        {{_P_diag}}[_i] = {{_P_diag}}[_i]  - subfac * {{_P_parent}}[_j-1]
        {{_B}}[_i] = {{_B}}[_i] - subfac * {{_B}}[_j]

# part 2: forwards substitution
{{_B}}[0] = {{_B}}[0] / {{_P_diag}}[0]  # the first branch does not have a parent
for _i, j in enumerate({{_morph_parent_i}}):
    {{_B}}[_i+1] -= {{_P_parent}}[_i] * {{_B}}[j]
    {{_B}}[_i+1] /= {{_P_diag}}[_i+1]

# For each branch compute the final solution by linear combination of the general solution
for _i, (_B_parent, _j_start, _j_end) in enumerate(zip({{_B}}[{{_morph_parent_i}}],
                                                       {{_starts}},
                                                       {{_ends}})):
    _B_current = {{_B}}[_i+1]
    if _j_start == _j_end:
        {{v}}[_j_start] = ({{v_star}}[_j_start] + _B_parent * {{u_minus}}[_j_start]
                     + _B_current * {{u_plus}}[_j_start])
    else:
        {{v}}[_j_start:_j_end+1] = ({{v_star}}[_j_start:_j_end+1] + _B_parent * {{u_minus}}[_j_start:_j_end+1]
                     + _B_current * {{u_plus}}[_j_start:_j_end+1])

