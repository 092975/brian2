{#
USES_VARIABLES { _synaptic_pre, _synaptic_post, _all_pre, _all_post, N,
                 N_pre, N_post, _source_offset, _target_offset }
#}
{# WRITES_TO_READ_ONLY_VARIABLES { _synaptic_pre, _synaptic_post, N}
#}
{# ITERATE_ALL { _idx } #}
import sys as _sys
import numpy as _numpy
from numpy.random import rand as _np_rand
if _sys.version_info[0]==2:
    range = xrange

from numpy.random import binomial as _binomial
try:
    from sklearn.utils.random import sample_without_replacement as _swr
    def _sample_without_replacement(n, p):
        k = _binomial(n, p)
        if p<0.01:
            samples = _swr(n, k, method='tracking_selection').astype(dtype=_numpy.int32)
            samples.sort()
        elif p<0.04:
            samples = _swr(n, k, method='pool').astype(dtype=_numpy.int32)
            samples.sort()
        else:
            samples, = (_np_rand(n)<p).nonzero()
        return samples
except ImportError:
    def _sample_without_replacement(n, p):
        samples, = (_np_rand(n)<p).nonzero()
        return samples

# number of synapses in the beginning
_old_num_synapses = {{N}}
# number of synapses during the creation process
_cur_num_synapses = _old_num_synapses

# scalar code
_vectorisation_idx = 1
{{scalar_code['setup_iterator']|autoindent}}
{{scalar_code['create_j']|autoindent}}
{{scalar_code['create_cond']|autoindent}}
{{scalar_code['update_post']|autoindent}}

_len_all_post = len({{_all_post}})

for _i in range(len({{_all_pre}})):
    {% if not postsynaptic_condition %}
    {{vector_code['create_cond']|autoindent}}
    if not _cond:
        continue
    {% endif %}
    {{vector_code['setup_iterator']|autoindent}}
    {% if iterator_func=='range' %}
    {{iteration_variable}} = _numpy.arange(_iter_low, _iter_high, _iter_step)
    {% elif iterator_func=='sample' %}
    {{iteration_variable}} = _numpy.arange(_iter_low, _iter_high, _iter_step)
    {{iteration_variable}} = {{iteration_variable}}[_sample_without_replacement(len({{iteration_variable}}), _iter_p)]
    {% endif %}

    _vectorisation_idx = {{iteration_variable}} # TODO: not sure if any of these _vectorisation_idx are correct
    {{vector_code['create_j']|autoindent}}
    _vectorisation_idx = _j
    {% if postsynaptic_condition %}
    {{vector_code['create_cond']|autoindent}}
    {% endif %}
    {% if if_expression!='True' and postsynaptic_condition %}
    _j, _cond = _numpy.broadcast_arrays(_j, _cond)
    _j = _j[_cond]
    {% else %}
    _j, {{iteration_variable}} = _numpy.broadcast_arrays(_j, {{iteration_variable}})
    {% endif %}

    _vectorisation_idx = _j
    {{vector_code['update_post']|autoindent}}

    if not _numpy.isscalar(_n):
        # The "n" expression involved j # TODO: is this correct? not sure about the index
        _post_idx = _post_idx.repeat(_n[_j])
    elif _n != 1:
        # We have a j-independent number
        _post_idx = _post_idx.repeat(_n)

    _numnew = len(_post_idx)
    _new_num_synapses = _cur_num_synapses + _numnew
    {{_dynamic__synaptic_pre}}.resize(_new_num_synapses)
    {{_dynamic__synaptic_post}}.resize(_new_num_synapses)
    {{_dynamic__synaptic_pre}}[_cur_num_synapses:] = _pre_idx
    {{_dynamic__synaptic_post}}[_cur_num_synapses:] = _post_idx
    _cur_num_synapses += _numnew

# Resize all dependent dynamic arrays (synaptic weights, delays, etc.) and set
# the total number of synapses
_owner._resize(_cur_num_synapses)

# And update N_incoming, N_outgoing and synapse_number
_owner._update_synapse_numbers(_old_num_synapses)
